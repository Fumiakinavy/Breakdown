# ViewModel/TaskBoardViewModel.swift ナラティブ

## 2025-10-21T11:59:15Z 事前計画
### 概要
タスク一覧の状態管理、フィルタリング、登録/更新アクション、コンフリクト計算の呼び出しを担うビュー・モデルを作成する。
### 目的
SwiftUIビューからの操作を集約し、UIを薄く保ちながらビジネスロジックをテスト可能にする。
### 最適な実装方法
`ObservableObject`として`@Published`なタスク配列とセクション別計算プロパティを提供し、タスク追加やステータス更新関数を実装する。
### 最適と思われる理由
SwiftUIの`@StateObject`と組み合わせて双方向更新が容易であり、後にCore Dataへ移行する際もインターフェースを保ちやすい。
### 入出力
入力: ユーザー操作（追加、分解承認、完了など）。  
出力: セクション別タスクリストやコンフリクトスコア。

## 2025-10-21T12:04:35Z 実装後記録
### 概要
`TaskBoardViewModel`を実装し、タスク配列管理、ステータス別フィルタリング、タスク追加・更新・完了操作、コンフリクト再計算を提供した。
### 目的
ビューがロジックを直接持たず、状態管理とコンフリクト分析を再利用できるようにする。
### 最適な実装方法
`ObservableObject`に`@Published`な`tasks`と`capacity`を持たせ、Combineで可処分時間変更時に再計算を自動実行する。
### 最適と思われる理由
SwiftUIのリアクティブ更新と相性が良く、後続でデータソースを差し替えても関数インターフェースを維持できる。
### 入出力
入力: 追加・更新・進捗操作、可処分時間設定。  
出力: ステータス別タスクリスト、各タスクのコンフリクトスコア。
### 実装の評価
主要な操作を網羅し、初期サンプルデータでも挙動確認できる。評価: 94/100。

## 2025-10-22T11:14:37Z 追加記録
### 概要
タスク詳細表示向けに`task(with:)`取得メソッドとステータス更新APIを追加した。
### 目的
詳細シートから最新データを参照しつつ、詳細化完了操作を行えるようにする。
### 最適な実装方法
配列検索で該当タスクを返すヘルパーと、ステータス更新時に完了日時を調整する関数を追加。
### 最適と思われる理由
ビュー・モデルの責務内で操作を完結でき、今後のロジック拡張にも応用しやすい。
### 入出力
入力: タスクIDと更新ステータス。  
出力: 更新後のタスク配列と再計算されたコンフリクト。
### 実装の評価
詳細シートとの連携がスムーズになり、状態管理の一貫性を保てた。評価: 95/100。

## 2025-10-22T11:17:55Z 追加記録
### 概要
ステップのドラッグ並べ替えに対応する`reorderSteps`メソッドを実装した。
### 目的
詳細シートからステップ順序を変更し、実行計画の調整を反映できるようにする。
### 最適な実装方法
`Array.move`を利用してステップ配列を並べ替え、`orderIndex`を再採番したうえでコンフリクト計算を再実行する。
### 最適と思われる理由
既存の`Task`値型構造を保ちつつ、順序変更後もデータ整合性とスコア更新が担保される。
### 入出力
入力: タスクID、移動元`IndexSet`、移動先オフセット。  
出力: 並べ替え後のステップ配列。
### 実装の評価
UIからのドラッグ操作とデータ層更新が同期し、次のコミットでの追加作業は不要。評価: 96/100。

## 2025-10-22T14:24:04Z 追加記録
### 概要
グラフ編集用に履歴管理、ノード追加・移動、Undo/Redo、ノード名変更などの機能を追加した。
### 目的
グラフエディタUIからの操作をデータモデルへ反映し、ユーザー操作のやり直しにも対応する。
### 最適な実装方法
`GraphHistory`で履歴スタックを保持し、ノード配列を正規化座標で更新するメソッドを提供。`moveItems`で独自の並べ替え処理を実装。
### 最適と思われる理由
SwiftUI依存を最小化しつつ柔軟なグラフ操作を実現でき、将来的な同期処理とも整合しやすい。
### 入出力
入力: ノード追加・位置変更・Undo/Redoイベント。  
出力: 更新後の`Task`、履歴スタック。
### 実装の評価
グラフUIと密接に連携できるロジックが整備され、ユーザー要望に沿った操作性を担保。評価: 95/100。
